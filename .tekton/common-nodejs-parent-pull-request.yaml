apiVersion: tekton.dev/v1
kind: PipelineRun
metadata:
  annotations:
    build.appstudio.openshift.io/repo: https://github.com/spork-madness/common-nodejs-parent?rev={{revision}}
    build.appstudio.redhat.com/commit_sha: '{{revision}}'
    build.appstudio.redhat.com/pull_request_number: '{{pull_request_number}}'
    build.appstudio.redhat.com/target_branch: '{{target_branch}}'
    pipelinesascode.tekton.dev/max-keep-runs: "3"
    pipelinesascode.tekton.dev/on-cel-expression: event == "pull_request" && target_branch
      == "main"
  creationTimestamp: null
  labels:
    appstudio.openshift.io/application: build-nudge-example
    appstudio.openshift.io/component: common-nodejs-parent
    pipelines.appstudio.openshift.io/type: build
  name: common-nodejs-parent-on-pull-request
  namespace: arewm-tenant
spec:
  params:
  - name: dockerfile
    value: Dockerfile.nodejs-18
  - name: git-url
    value: '{{repo_url}}'
  - name: image-expires-after
    value: 5d
  - name: output-image
    value: quay.io/redhat-user-workloads/arewm-tenant/build-nudge-example/common-nodejs-parent:on-pr-{{revision}}
  - name: path-context
    value: .
  - name: revision
    value: '{{revision}}'
  pipelineSpec:
    finally:
    - name: show-sbom
      params:
      - name: IMAGE_URL
        value: $(tasks.build-container.results.IMAGE_URL)
      taskRef:
        params:
        - name: name
          value: show-sbom
        - name: bundle
          value: quay.io/redhat-appstudio-tekton-catalog/task-show-sbom:0.1@sha256:202d3c3385120ea847d8f0a82bd8d9d5e873d67f981d6f8a51fb1706caaf6bef
        - name: kind
          value: task
        resolver: bundles
    - name: show-summary
      params:
      - name: pipelinerun-name
        value: $(context.pipelineRun.name)
      - name: git-url
        value: $(tasks.clone-repository.results.url)?rev=$(tasks.clone-repository.results.commit)
      - name: image-url
        value: $(params.output-image)
      - name: build-task-status
        value: $(tasks.build-container.status)
      taskRef:
        params:
        - name: name
          value: summary
        - name: bundle
          value: quay.io/redhat-appstudio-tekton-catalog/task-summary:0.1@sha256:f65a69aaf71cbab382eff685eee522ad35068a4d91d233e76cef7d42ff15a686
        - name: kind
          value: task
        resolver: bundles
    params:
    - description: Source Repository URL
      name: git-url
      type: string
    - default: ""
      description: Revision of the Source Repository
      name: revision
      type: string
    - description: Fully Qualified Output Image
      name: output-image
      type: string
    - default: .
      description: Path to the source code of an application's component from where
        to build image.
      name: path-context
      type: string
    - default: Dockerfile
      description: Path to the Dockerfile inside the context specified by parameter
        path-context
      name: dockerfile
      type: string
    - default: "false"
      description: Force rebuild image
      name: rebuild
      type: string
    - default: "false"
      description: Skip checks against built image
      name: skip-checks
      type: string
    - default: "true"
      description: Skip optional checks, set false if you want to run optional checks
      name: skip-optional
      type: string
    - default: "false"
      description: Execute the build with network isolation
      name: hermetic
      type: string
    - default: ""
      description: Build dependencies to be prefetched by Cachi2
      name: prefetch-input
      type: string
    - default: "false"
      description: Java build
      name: java
      type: string
    - default: ""
      description: Image tag expiration time, time values could be something like
        1h, 2d, 3w for hours, days, and weeks, respectively.
      name: image-expires-after
    - default: "false"
      description: Build a source image.
      name: build-source-image
      type: string
    results:
    - description: ""
      name: IMAGE_URL
      value: $(tasks.build-container.results.IMAGE_URL)
    - description: ""
      name: IMAGE_DIGEST
      value: $(tasks.build-container.results.IMAGE_DIGEST)
    - description: ""
      name: CHAINS-GIT_URL
      value: $(tasks.clone-repository.results.url)
    - description: ""
      name: CHAINS-GIT_COMMIT
      value: $(tasks.clone-repository.results.commit)
    - description: ""
      name: JAVA_COMMUNITY_DEPENDENCIES
      value: $(tasks.build-container.results.JAVA_COMMUNITY_DEPENDENCIES)
    tasks:
    - name: init
      params:
      - name: image-url
        value: $(params.output-image)
      - name: rebuild
        value: $(params.rebuild)
      - name: skip-checks
        value: $(params.skip-checks)
      - name: skip-optional
        value: $(params.skip-optional)
      - name: pipelinerun-name
        value: $(context.pipelineRun.name)
      - name: pipelinerun-uid
        value: $(context.pipelineRun.uid)
      taskRef:
        params:
        - name: name
          value: init
        - name: bundle
          value: quay.io/redhat-appstudio-tekton-catalog/task-init:0.1@sha256:c35cc37d6f40fef0f2ed614b502b058e13fe7af29c0888bc4799fd625b6f3374
        - name: kind
          value: task
        resolver: bundles
    - name: clone-repository
      params:
      - name: url
        value: $(params.git-url)
      - name: revision
        value: $(params.revision)
      runAfter:
      - init
      taskRef:
        params:
        - name: name
          value: git-clone
        - name: bundle
          value: quay.io/redhat-appstudio-tekton-catalog/task-git-clone:0.1@sha256:b8fddc2d36313a5cde93aba2491205f4a84e6853af6c34ede681f8339b147478
        - name: kind
          value: task
        resolver: bundles
      when:
      - input: $(tasks.init.results.build)
        operator: in
        values:
        - "true"
      workspaces:
      - name: output
        workspace: workspace
      - name: basic-auth
        workspace: git-auth
    - name: prefetch-dependencies
      params:
      - name: input
        value: $(params.prefetch-input)
      runAfter:
      - clone-repository
      taskRef:
        params:
        - name: name
          value: prefetch-dependencies
        - name: bundle
          value: quay.io/redhat-appstudio-tekton-catalog/task-prefetch-dependencies:0.1@sha256:9630dd7d50002fdffb4a406fb0c538703ef98bf2f4318249ac3a2c229938dbea
        - name: kind
          value: task
        resolver: bundles
      when:
      - input: $(params.hermetic)
        operator: in
        values:
        - "true"
      workspaces:
      - name: source
        workspace: workspace
    - name: build-container
      params:
      - name: IMAGE
        value: $(params.output-image)
      - name: DOCKERFILE
        value: $(params.dockerfile)
      - name: CONTEXT
        value: $(params.path-context)
      - name: HERMETIC
        value: $(params.hermetic)
      - name: PREFETCH_INPUT
        value: $(params.prefetch-input)
      - name: IMAGE_EXPIRES_AFTER
        value: $(params.image-expires-after)
      - value: ""
        name: DISABLE_IMAGE_INDEX
      - name: COMMIT_SHA
        value: $(tasks.clone-repository.results.commit)
      runAfter:
      - prefetch-dependencies
      taskSpec:
        params:
        - description: Reference of the image buildah will produce.
          name: IMAGE
          type: string
        - default: ""
          description: Disable the generation of an OCI Image Index. Empty means that `params.IMAGE` will be an Image Index. Any content will result in `params.IMAGE` being an OCI Image Manifest.
          name: DISABLE_IMAGE_INDEX
          type: string
        - default: quay.io/redhat-appstudio/buildah:v1.31.0@sha256:34f12c7b72ec2c28f1ded0c494b428df4791c909f1f174dd21b8ed6a57cf5ddb
          # per https://kubernetes.io/docs/concepts/containers/images/#imagepullpolicy-defaulting
          # the cluster will set imagePullPolicy to IfNotPresent
          # also per direction from Ralph Bean, we want to use image digest based tags to use a cue to automation like dependabot or renovatebot to periodially submit pull requests that update the digest as new images are released.
          description: The location of the buildah builder image.
          name: BUILDER_IMAGE
          type: string
        - default: ./Dockerfile
          description: Path to the Dockerfile to build.
          name: DOCKERFILE
          type: string
        - default: .
          description: Path to the directory to use as context.
          name: CONTEXT
          type: string
        - default: "true"
          description: Verify the TLS on the registry endpoint (for push/pull to a non-TLS registry)
          name: TLSVERIFY
          type: string
        - description: unused, should be removed in next task version
          name: DOCKER_AUTH
          type: string
          default: ""
        - default: "false"
          description: Determines if build will be executed without network access.
          name: HERMETIC
          type: string
        - default: ""
          description: In case it is not empty, the prefetched content should be made available to the build.
          name: PREFETCH_INPUT
          type: string
        - default: ""
          description: Delete image tag after specified time. Empty means to keep the image tag. Time values could be something like 1h, 2d, 3w for hours, days, and weeks, respectively.
          name: IMAGE_EXPIRES_AFTER
          type: string
        - name: COMMIT_SHA
          description: The image is built from this commit.
          type: string
          default: ""
        - name: YUM_REPOS_D_SRC
          description: Path in the git repository in which yum repository files are stored
          default: repos.d
        - name: YUM_REPOS_D_FETCHED
          description: Path in source workspace where dynamically-fetched repos are present
          default: fetched.repos.d
        - name: YUM_REPOS_D_TARGET
          description: Target path on the container in which yum repository files should be made available
          default: /etc/yum.repos.d
        results:
        - description: Digest of the image just built
          name: IMAGE_DIGEST
        - description: Image repository where the built image was pushed
          name: IMAGE_URL
        - description: Digests of the base images used for build
          name: BASE_IMAGES_DIGESTS
        - name: SBOM_JAVA_COMPONENTS_COUNT
          description: The counting of Java components by publisher in JSON format
        - name: JAVA_COMMUNITY_DEPENDENCIES
          description: The Java dependencies that came from community sources such as Maven central.
        stepTemplate:
          env:
          - name: BUILDAH_FORMAT
            value: oci
          - name: STORAGE_DRIVER
            value: vfs
          - name: HERMETIC
            value: $(params.HERMETIC)
          - name: PREFETCH_INPUT
            value: $(params.PREFETCH_INPUT)
          - name: CONTEXT
            value: $(params.CONTEXT)
          - name: DOCKERFILE
            value: $(params.DOCKERFILE)
          - name: IMAGE
            value: $(params.IMAGE)
          - name: DISABLE_IMAGE_INDEX
            value: $(params.DISABLE_IMAGE_INDEX)
          - name: TLSVERIFY
            value: $(params.TLSVERIFY)
          - name: IMAGE_EXPIRES_AFTER
            value: $(params.IMAGE_EXPIRES_AFTER)
          - name: YUM_REPOS_D_SRC
            value: $(params.YUM_REPOS_D_SRC)
          - name: YUM_REPOS_D_FETCHED
            value: $(params.YUM_REPOS_D_FETCHED)
          - name: YUM_REPOS_D_TARGET
            value: $(params.YUM_REPOS_D_TARGET)
        steps:
        - image: $(params.BUILDER_IMAGE)
          # per https://kubernetes.io/docs/concepts/containers/images/#imagepullpolicy-defaulting
          # the cluster will set imagePullPolicy to IfNotPresent; our default param above specifies a digest
          # also per direction from Ralph Bean, we want to use image digest based tags to use a cue to automation like dependabot or renovatebot to periodially submit pull requests that update the digest as new images are released.
          name: build
          computeResources:
            limits:
              memory: 4Gi
            requests:
              memory: 512Mi
              cpu: 250m
          env:
          - name: COMMIT_SHA
            value: $(params.COMMIT_SHA)
          script: |
            SOURCE_CODE_DIR=source
            if [ -e "$SOURCE_CODE_DIR/$CONTEXT/$DOCKERFILE" ]; then
              dockerfile_path="$SOURCE_CODE_DIR/$CONTEXT/$DOCKERFILE"
            elif [ -e "$SOURCE_CODE_DIR/$DOCKERFILE" ]; then
              dockerfile_path="$SOURCE_CODE_DIR/$DOCKERFILE"
            elif echo "$DOCKERFILE" | grep -q "^https\?://"; then
              echo "Fetch Dockerfile from $DOCKERFILE"
              dockerfile_path=$(mktemp --suffix=-Dockerfile)
              http_code=$(curl -s -L -w "%{http_code}" --output "$dockerfile_path" "$DOCKERFILE")
              if [ $http_code != 200 ]; then
                echo "No Dockerfile is fetched. Server responds $http_code"
                exit 1
              fi
              http_code=$(curl -s -L -w "%{http_code}" --output "$dockerfile_path.dockerignore.tmp" "$DOCKERFILE.dockerignore")
              if [ $http_code = 200 ]; then
                echo "Fetched .dockerignore from $DOCKERFILE.dockerignore"
                mv "$dockerfile_path.dockerignore.tmp" $SOURCE_CODE_DIR/$CONTEXT/.dockerignore
              fi
            else
              echo "Cannot find Dockerfile $DOCKERFILE"
              exit 1
            fi
            if [ -n "$JVM_BUILD_WORKSPACE_ARTIFACT_CACHE_PORT_80_TCP_ADDR" ] && grep -q '^\s*RUN \(./\)\?mvn' "$dockerfile_path"; then
              sed -i -e "s|^\s*RUN \(\(./\)\?mvn\)\(.*\)|RUN echo \"<settings><mirrors><mirror><id>mirror.default</id><url>http://$JVM_BUILD_WORKSPACE_ARTIFACT_CACHE_PORT_80_TCP_ADDR/v1/cache/default/0/</url><mirrorOf>*</mirrorOf></mirror></mirrors></settings>\" > /tmp/settings.yaml; \1 -s /tmp/settings.yaml \3|g" "$dockerfile_path"
              touch /var/lib/containers/java
            fi

            # Fixing group permission on /var/lib/containers
            chown root:root /var/lib/containers

            sed -i 's/^\s*short-name-mode\s*=\s*.*/short-name-mode = "disabled"/' /etc/containers/registries.conf

            # Setting new namespace to run buildah - 2^32-2
            echo 'root:1:4294967294' | tee -a /etc/subuid >> /etc/subgid

            if [ "${HERMETIC}" == "true" ]; then
              BUILDAH_ARGS="--pull=never"
              UNSHARE_ARGS="--net"
              for image in $(grep -i '^\s*FROM' "$dockerfile_path" | sed 's/--platform=\S*//' | awk '{print $2}'); do
                if [ "${image}" != "scratch" ]; then
                  unshare -Ufp --keep-caps -r --map-users 1,1,65536 --map-groups 1,1,65536 -- buildah pull $image
                fi
              done
              echo "Build will be executed with network isolation"
            fi

            if [ -n "${PREFETCH_INPUT}" ]; then
              cp -r cachi2 /tmp/
              chmod -R go+rwX /tmp/cachi2
              VOLUME_MOUNTS="--volume /tmp/cachi2:/cachi2"
              sed -i 's|^\s*run |RUN . /cachi2/cachi2.env \&\& \\\n    |i' "$dockerfile_path"
              echo "Prefetched content will be made available"
            fi

            # if yum repofiles stored in git, copy them to mount point outside the source dir
            if [ -d "${SOURCE_CODE_DIR}/${YUM_REPOS_D_SRC}" ]; then
              mkdir -p ${YUM_REPOS_D_FETCHED}
              cp -r ${SOURCE_CODE_DIR}/${YUM_REPOS_D_SRC}/* ${YUM_REPOS_D_FETCHED}
            fi

            # if anything in the repofiles mount point (either fetched or from git), mount it
            if [ -d "${YUM_REPOS_D_FETCHED}" ]; then
              chmod -R go+rwX ${YUM_REPOS_D_FETCHED}
              mount_point=$(realpath ${YUM_REPOS_D_FETCHED})
              VOLUME_MOUNTS="${VOLUME_MOUNTS} --volume ${mount_point}:${YUM_REPOS_D_TARGET}"
            fi

            LABELS=(
              "--label" "build-date=$(date -u +'%Y-%m-%dT%H:%M:%S')"
              "--label" "architecture=$(uname -m)"
              "--label" "vcs-type=git"
            )
            [ -n "$COMMIT_SHA" ] && LABELS+=("--label" "vcs-ref=$COMMIT_SHA")
            [ -n "$IMAGE_EXPIRES_AFTER" ] && LABELS+=("--label" "quay.expires-after=$IMAGE_EXPIRES_AFTER")

            unshare -Uf $UNSHARE_ARGS --keep-caps -r --map-users 1,1,65536 --map-groups 1,1,65536 -- buildah build \
              $VOLUME_MOUNTS \
              $BUILDAH_ARGS \
              ${LABELS[@]} \
              --tls-verify=$TLSVERIFY --no-cache \
              --ulimit nofile=4096:4096 \
              -f "$dockerfile_path" -t $IMAGE $SOURCE_CODE_DIR/$CONTEXT

            container=$(buildah from --pull-never $IMAGE)
            buildah mount $container | tee /workspace/container_path
            echo $container > /workspace/container_name

            # Save the SBOM produced by Cachi2 so it can be merged into the final SBOM later
            if [ -n "${PREFETCH_INPUT}" ]; then
              cp /tmp/cachi2/output/bom.json ./sbom-cachi2.json
            fi

            # Expose base image digests
            buildah images --format '{{ .Name }}:{{ .Tag }}@{{ .Digest }}' | grep -v $IMAGE > $(results.BASE_IMAGES_DIGESTS.path)

          securityContext:
            capabilities:
              add:
                - SETFCAP
          volumeMounts:
          - mountPath: /var/lib/containers
            name: varlibcontainers
          workingDir: $(workspaces.source.path)

        - name: sbom-syft-generate
          image: quay.io/redhat-appstudio/syft:v0.98.0@sha256:4d3856e6a2622700b9a9d5d74d9aaf5d8a55671653f80bf6c636677658680ede
          # per https://kubernetes.io/docs/concepts/containers/images/#imagepullpolicy-defaulting
          # the cluster will set imagePullPolicy to IfNotPresent
          # also per direction from Ralph Bean, we want to use image digest based tags to use a cue to automation like dependabot or renovatebot to periodially submit pull requests that update the digest as new images are released.
          script: |
            syft dir:$(workspaces.source.path)/source --output cyclonedx-json=$(workspaces.source.path)/sbom-source.json
            find $(cat /workspace/container_path) -xtype l -delete
            syft dir:$(cat /workspace/container_path) --output cyclonedx-json=$(workspaces.source.path)/sbom-image.json
          volumeMounts:
          - mountPath: /var/lib/containers
            name: varlibcontainers
        - name: analyse-dependencies-java-sbom
          image: quay.io/redhat-appstudio/hacbs-jvm-build-request-processor:127ee0c223a2b56a9bd20a6f2eaeed3bd6015f77
          # per https://kubernetes.io/docs/concepts/containers/images/#imagepullpolicy-defaulting
          # the cluster will set imagePullPolicy to IfNotPresent
          # also per direction from Ralph Bean, we want to use image digest based tags to use a cue to automation like dependabot or renovatebot to periodially submit pull requests that update the digest as new images are released.
          script: |
            if [ -f /var/lib/containers/java ]; then
              /opt/jboss/container/java/run/run-java.sh analyse-dependencies path $(cat /workspace/container_path) -s $(workspaces.source.path)/sbom-image.json --task-run-name $(context.taskRun.name) --publishers $(results.SBOM_JAVA_COMPONENTS_COUNT.path)
              sed -i 's/^/ /' $(results.SBOM_JAVA_COMPONENTS_COUNT.path) # Workaround for SRVKP-2875
            else
              touch $(results.JAVA_COMMUNITY_DEPENDENCIES.path)
            fi
          volumeMounts:
          - mountPath: /var/lib/containers
            name: varlibcontainers
          securityContext:
            runAsUser: 0

        - name: merge-syft-sboms
          image: registry.access.redhat.com/ubi9/python-39:1-158@sha256:967000729b17efdea309e297f4b1961c38b902a1ef18f6d886b8086c2a12f01f
          # per https://kubernetes.io/docs/concepts/containers/images/#imagepullpolicy-defaulting
          # the cluster will set imagePullPolicy to IfNotPresent
          # also per direction from Ralph Bean, we want to use image digest based tags to use a cue to automation like dependabot or renovatebot to periodially submit pull requests that update the digest as new images are released.
          script: |
            #!/bin/python3
            import json

            # load SBOMs
            with open("./sbom-image.json") as f:
              image_sbom = json.load(f)

            with open("./sbom-source.json") as f:
              source_sbom = json.load(f)

            # fetch unique components from available SBOMs
            def get_identifier(component):
              return component["name"] + '@' + component.get("version", "")

            image_sbom_components = image_sbom.get("components", [])
            existing_components = [get_identifier(component) for component in image_sbom_components]

            source_sbom_components = source_sbom.get("components", [])
            for component in source_sbom_components:
              if get_identifier(component) not in existing_components:
                image_sbom_components.append(component)
                existing_components.append(get_identifier(component))

            image_sbom_components.sort(key=lambda c: get_identifier(c))

            # write the CycloneDX unified SBOM
            with open("./sbom-cyclonedx.json", "w") as f:
              json.dump(image_sbom, f, indent=4)
          workingDir: $(workspaces.source.path)
          securityContext:
            runAsUser: 0

        - name: merge-cachi2-sbom
          image: quay.io/redhat-appstudio/cachi2:0.4.0@sha256:001acfbad47e132a90998d45076a0dbe0d8beacf0bec12b4d9a5aa796f4a9cad
          # per https://kubernetes.io/docs/concepts/containers/images/#imagepullpolicy-defaulting
          # the cluster will set imagePullPolicy to IfNotPresent
          # also per direction from Ralph Bean, we want to use image digest based tags to use a cue to automation like dependabot or renovatebot to periodially submit pull requests that update the digest as new images are released.
          script: |
            if [ -n "${PREFETCH_INPUT}" ]; then
              echo "Merging contents of sbom-cachi2.json into sbom-cyclonedx.json"
              /src/utils/merge_syft_sbom.py sbom-cachi2.json sbom-cyclonedx.json > sbom-temp.json
              mv sbom-temp.json sbom-cyclonedx.json
            else
              echo "Skipping step since no Cachi2 SBOM was produced"
            fi
          workingDir: $(workspaces.source.path)
          securityContext:
            runAsUser: 0

        - name: create-purl-sbom
          image: registry.access.redhat.com/ubi9/python-39:1-158@sha256:967000729b17efdea309e297f4b1961c38b902a1ef18f6d886b8086c2a12f01f
          # per https://kubernetes.io/docs/concepts/containers/images/#imagepullpolicy-defaulting
          # the cluster will set imagePullPolicy to IfNotPresent
          # also per direction from Ralph Bean, we want to use image digest based tags to use a cue to automation like dependabot or renovatebot to periodially submit pull requests that update the digest as new images are released.
          script: |
            #!/bin/python3
            import json

            with open("./sbom-cyclonedx.json") as f:
              cyclonedx_sbom = json.load(f)

            purls = [{"purl": component["purl"]} for component in cyclonedx_sbom.get("components", []) if "purl" in component]
            purl_content = {"image_contents": {"dependencies": purls}}

            with open("sbom-purl.json", "w") as output_file:
              json.dump(purl_content, output_file, indent=4)
          workingDir: $(workspaces.source.path)
          securityContext:
            runAsUser: 0

        - name: inject-sbom-and-push
          image: $(params.BUILDER_IMAGE)
          computeResources: {}
          script: |
            base_image_name=$(buildah inspect --format '{{ index .ImageAnnotations "org.opencontainers.image.base.name"}}' $IMAGE | cut -f1 -d'@')
            base_image_digest=$(buildah inspect --format '{{ index .ImageAnnotations "org.opencontainers.image.base.digest"}}' $IMAGE)
            container=$(buildah from --pull-never $IMAGE)
            buildah copy $container sbom-cyclonedx.json sbom-purl.json /root/buildinfo/content_manifests/
            buildah config -a org.opencontainers.image.base.name=${base_image_name} -a org.opencontainers.image.base.digest=${base_image_digest} $container
            #buildah commit $container $IMAGE
            
            IMAGE_PUSH="$IMAGE"
            if [ -n "${DISABLE_IMAGE_INDEX}" ]; then
              echo "Skipping production of OCI Image Index"
              buildah commit $container $IMAGE
            else
              echo "Generating OCI Image Index"
              IMAGE_PUSH="$IMAGE-index"
              buildah commit --manifest $IMAGE_PUSH $container $IMAGE
            fi

            #IMAGE_PUSH="$IMAGE"
            #echo "DISABLE_IMAGE_INDEX: ${DISABLE_IMAGE_INDEX}"
            #echo "$IMAGE"
            #echo "$IMAGE_PUSH"
            #buildah images
            #if [ -n "${DISABLE_IMAGE_INDEX}" ]; then
            #  echo "Skipping production of OCI Image Index"
            #else
            #  IMAGE_PUSH="$IMAGE-index"
            #  echo "Adding $IMAGE to an OCI Image Index"
            #  echo "  Temporary Image Index: $IMAGE_PUSH"
            #  buildah manifest create "$IMAGE_PUSH"
            #  buildah manifest add $IMAGE_PUSH "docker://$IMAGE"
            #fi

            status=-1
            max_run=5
            sleep_sec=10
            for run in $(seq 1 $max_run); do
              status=0
              [ "$run" -gt 1 ] && sleep $sleep_sec
              echo "Pushing sbom image to registry"
              if [ -n "${DISABLE_IMAGE_INDEX}" ]; then
                buildah push \
                --tls-verify=$TLSVERIFY \
                --digestfile $(workspaces.source.path)/image-digest $IMAGE_PUSH \
                docker://$IMAGE && break || status=$?
              else
                buildah manifest push --all \
                --tls-verify=$TLSVERIFY \
                --digestfile $(workspaces.source.path)/image-digest $IMAGE_PUSH \
                docker://$IMAGE && break || status=$?
              fi
            done
            if [ "$status" -ne 0 ]; then
                echo "Failed to push sbom image to registry after ${max_run} tries"
                exit 1
            fi

            cat "$(workspaces.source.path)"/image-digest | tee $(results.IMAGE_DIGEST.path)
            echo -n "$IMAGE" | tee $(results.IMAGE_URL.path)

          securityContext:
            runAsUser: 0
            capabilities:
              add:
                - SETFCAP
          volumeMounts:
          - mountPath: /var/lib/containers
            name: varlibcontainers
          workingDir: $(workspaces.source.path)

        - name: upload-sbom
          image: quay.io/redhat-appstudio/cosign:v2.1.1@sha256:c883d6f8d39148f2cea71bff4622d196d89df3e510f36c140c097b932f0dd5d5
          # per https://kubernetes.io/docs/concepts/containers/images/#imagepullpolicy-defaulting
          # the cluster will set imagePullPolicy to IfNotPresent
          # also per direction from Ralph Bean, we want to use image digest based tags to use a cue to automation like dependabot or renovatebot to periodially submit pull requests that update the digest as new images are released.
          args:
            - attach
            - sbom
            - --sbom
            - sbom-cyclonedx.json
            - --type
            - cyclonedx
            - $(params.IMAGE)
          workingDir: $(workspaces.source.path)

        volumes:
        - emptyDir: {}
          name: varlibcontainers
        workspaces:
        - name: source
          description: Workspace containing the source code to build.
      when:
      - input: $(tasks.init.results.build)
        operator: in
        values:
        - "true"
      workspaces:
      - name: source
        workspace: workspace
    - name: build-source-image
      params:
      - name: BINARY_IMAGE
        value: $(params.output-image)
      - name: BASE_IMAGES
        value: $(tasks.build-container.results.BASE_IMAGES_DIGESTS)
      runAfter:
      - build-container
      taskRef:
        params:
        - name: name
          value: source-build
        - name: bundle
          value: quay.io/redhat-appstudio-tekton-catalog/task-source-build:0.1@sha256:f8c5dec871fb5347eb2fc61d44754bcc101897aecf953b374ab3e8315e1a9804
        - name: kind
          value: task
        resolver: bundles
      when:
      - input: $(tasks.init.results.build)
        operator: in
        values:
        - "true"
      - input: $(params.build-source-image)
        operator: in
        values:
        - "true"
      workspaces:
      - name: workspace
        workspace: workspace
    - name: deprecated-base-image-check
      params:
      - name: BASE_IMAGES_DIGESTS
        value: $(tasks.build-container.results.BASE_IMAGES_DIGESTS)
      runAfter:
      - build-container
      taskRef:
        params:
        - name: name
          value: deprecated-image-check
        - name: bundle
          value: quay.io/redhat-appstudio-tekton-catalog/task-deprecated-image-check:0.3@sha256:d87f8c50a674f57527a0c4f3df6d9093941a2ae84739b55368b3c11702ce340c
        - name: kind
          value: task
        resolver: bundles
      when:
      - input: $(params.skip-checks)
        operator: in
        values:
        - "false"
    - name: clair-scan
      params:
      - name: image-digest
        value: $(tasks.build-container.results.IMAGE_DIGEST)
      - name: image-url
        value: $(tasks.build-container.results.IMAGE_URL)
      runAfter:
      - build-container
      taskRef:
        params:
        - name: name
          value: clair-scan
        - name: bundle
          value: quay.io/redhat-appstudio-tekton-catalog/task-clair-scan:0.1@sha256:fbe1ab58531d856fba360060d3884a0606310a966e2d01ba9305da9eb01ab916
        - name: kind
          value: task
        resolver: bundles
      when:
      - input: $(params.skip-checks)
        operator: in
        values:
        - "false"
    - name: sast-snyk-check
      runAfter:
      - clone-repository
      taskRef:
        params:
        - name: name
          value: sast-snyk-check
        - name: bundle
          value: quay.io/redhat-appstudio-tekton-catalog/task-sast-snyk-check:0.1@sha256:eee508768b14655275fbcc2f42f9da1ab553b872dcbe113b0896aa9bcf7e1adf
        - name: kind
          value: task
        resolver: bundles
      when:
      - input: $(params.skip-checks)
        operator: in
        values:
        - "false"
      workspaces:
      - name: workspace
        workspace: workspace
    - name: clamav-scan
      params:
      - name: image-digest
        value: $(tasks.build-container.results.IMAGE_DIGEST)
      - name: image-url
        value: $(tasks.build-container.results.IMAGE_URL)
      runAfter:
      - build-container
      taskRef:
        params:
        - name: name
          value: clamav-scan
        - name: bundle
          value: quay.io/redhat-appstudio-tekton-catalog/task-clamav-scan:0.1@sha256:d72cb58db88289559676676c3db43906718028e07279f70ddb12ed8bdc8e2860
        - name: kind
          value: task
        resolver: bundles
      when:
      - input: $(params.skip-checks)
        operator: in
        values:
        - "false"
    - name: sbom-json-check
      params:
      - name: IMAGE_URL
        value: $(tasks.build-container.results.IMAGE_URL)
      - name: IMAGE_DIGEST
        value: $(tasks.build-container.results.IMAGE_DIGEST)
      runAfter:
      - build-container
      taskRef:
        params:
        - name: name
          value: sbom-json-check
        - name: bundle
          value: quay.io/redhat-appstudio-tekton-catalog/task-sbom-json-check:0.1@sha256:717e6e33f02dbe1a28fb743f32699e002c944680c251a50b644f27becb9208e9
        - name: kind
          value: task
        resolver: bundles
      when:
      - input: $(params.skip-checks)
        operator: in
        values:
        - "false"
    workspaces:
    - name: workspace
    - name: git-auth
      optional: true
  taskRunTemplate: {}
  workspaces:
  - name: workspace
    volumeClaimTemplate:
      metadata:
        creationTimestamp: null
      spec:
        accessModes:
        - ReadWriteOnce
        resources:
          requests:
            storage: 1Gi
      status: {}
  - name: git-auth
    secret:
      secretName: '{{ git_auth_secret }}'
status: {}
